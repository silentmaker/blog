webpackJsonp([0xc99dde3f7158],{484:function(n,l){n.exports={data:{site:{siteMetadata:{title:"Elvin's Blog",author:"Elvin Ma"}},markdownRemark:{id:"/Users/maxingcong/Code/blog/src/pages/前端安全 - XSS总结.md absPath of file >>> MarkdownRemark",html:'<p>XSS，Cross Site Scripting，即跨站脚本执行，是一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本JS代码，使之得以在用户的浏览器上运行，利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全</p>\n<p>本质上说就是，恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行，在有输入限制的情况下，注入的恶意脚本一般比较短，但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略</p>\n<h3>常见攻击场景</h3>\n<ul>\n<li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入</li>\n<li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）</li>\n<li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签</li>\n<li>在标签的 href、src 等属性中，包含 javascript: 等可执行代码</li>\n<li>在 onload、onerror、onclick 等事件中，注入不受控制代码</li>\n<li>在 style 属性和标签中，包含类似 backgroundimage: url(“javascript:…“); 的代码（浏览器已经可以防范）。</li>\n<li>在 style 属性和标签中，包含类似 expression(…) 的 CSS 表达式代码（浏览器已经可以防范）</li>\n</ul>\n<p>不仅仅是业务上的UGC内容可能会被注入，还包括 URL 上的参数等，都可以是攻击的来源，所以我们要在假设一切输入都不可信的前提下处理内容，包括：</p>\n<ul>\n<li>来自用户的 UGC 信息</li>\n<li>来自第三方的链接</li>\n<li>URL 参数</li>\n<li>POST 参数</li>\n<li>Referer （可能来自不可信的来源）</li>\n<li>Cookie （可能来自其他子域注入）</li>\n</ul>\n<h3>XSS分类</h3>\n<p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种：</p>\n<p><strong>存储型 XSS</strong></p>\n<p>攻击步骤：</p>\n<ol>\n<li>攻击者将恶意代码提交到目标网站的数据库中</li>\n<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>\n</ol>\n<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等</p>\n<p><strong>反射型 XSS</strong></p>\n<p>攻击步骤：</p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>\n<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li>\n<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>\n</ol>\n<p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等，由于需要用户主动打开恶意的 URL 才能生效，它和存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里</p>\n<p><strong>DOM 型 XSS</strong></p>\n<p>攻击步骤：</p>\n<ol>\n<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>\n<li>用户打开带有恶意代码的 URL。</li>\n<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>\n<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>\n</ol>\n<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出恶意代码由前端完成，属于前端自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞</p>\n<h3>预防和检测</h3>\n<p>XSS 攻击有两大要素：攻击者提交恶意代码，以及浏览器执行恶意代码</p>\n<p>对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的，但有时输入过滤并非完全可靠，因为不管前端还是后端来做转义，得到的字符串就是转义后的字符，这个内容可能不能直接用于模板的展示，也不能直接用于内容长度计算，因此更关键地还是防止 HTML 中出现注入，和防止 JavaScript 执行时执行恶意代码</p>\n<p><strong>预防存储型和反射型 XSS 攻击</strong>，可以采用纯前端渲染，或者对 HTML 做充分转义</p>\n<p>纯前端渲染的过程就是现在说的单页应用，浏览器先加载一个静态 HTML，然后 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上</p>\n<p>在纯前端渲染中，我们可能明确的告诉浏览器要处理的内容是什么，比如要设置的内容是文本（ .innerText ），还是属性（ .setAttribute ），还是样式（ .style ）等等，这样浏览器不会被轻易的被欺骗，执行预期外的代码了，但纯前端渲染还需注意避免 DOM 型 XSS 漏洞，比如 onload 事件和 href 中的 javascript:xxx 等</p>\n<p>采用纯前端渲染是挺好的，但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题</p>\n<p>如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义，常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 &#x26; &#x3C; > ” ’ / 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善，最好能够更加全面的转义库，比如 Java 项目中，常用的转义库为 org.owasp.encoder </p>\n<p><strong>预防DOM 型 XSS 攻击</strong>，这类攻击实际上是前端代码本身不够严谨，把不可信的数据当作代码执行了</p>\n<p>在使用 .innerHTML 、.outerHTML 、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，应尽量使用.textContent 、.setAttribute() 等安全的方法</p>\n<p>如果用了 Vue/React 技术栈，并且不使用 v-html / dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML 、outerHTML 的 XSS 隐患</p>\n<p>DOM 中的内联事件监听器，如 location 、onclick 、onerror 、onload 、onmouseover 等， <a> 标签的 href 属性，JavaScript 的 eval() 、setTimeout() 、setInterval() 等，都能把字符串作为代码运行，如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患</p>\n<h3>其他通用方案</h3>\n<p><strong>Content Security Policy</strong>，严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p>\n<ul>\n<li>禁止加载外域代码，防止复杂的攻击逻辑</li>\n<li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域</li>\n<li>禁止内联脚本执行</li>\n<li>禁止未授权的脚本执行</li>\n<li>合理使用上报可以及时发现 XSS，利于尽快修复问题</li>\n<li>输入内容长度控制</li>\n</ul>\n<p>更多关于CSP的内容可见：<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">MDN - CSP</a></p>\n<p><strong>输入内容长度控制</strong>，对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度</p>\n<p><strong>HTTP-only Cookie</strong>， 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie</p>\n<p><strong>验证码</strong>，防止脚本冒充用户提交危险操作</p>\n<p><strong>XSS的主动检测和发现</strong>，可以使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞</p>',frontmatter:{title:"前端安全 - XSS总结",tags:null,categories:["编程"],date:"May 21, 2018"}}},pathContext:{slug:"/前端安全 - XSS总结/",previous:{fields:{slug:"/Babel笔记/"},frontmatter:{path:"/babel-notes",title:"Babel笔记",tags:null,categories:["编程"]}},next:{fields:{slug:"/页面渲染问题总结/"},frontmatter:{path:"/render-performance-checklist",title:"页面渲染问题总结",tags:["前端"],categories:["编程"]}}}}}});
//# sourceMappingURL=path---前端安全-xss总结-b98d5fe023c2e3688a99.js.map