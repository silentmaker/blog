---
title: '内存管理与垃圾回收'
date: '2017-04-29'
tags: ['Javascript']
categories: ['编程']
path: '/js-memory-management'
---

在C之类的语言中，开发者必须手动地调用和释放内存，也就是手动地调用malloc()、calloc()、realloc() 和 free() 等方法，而在 Java或者Javascript的高级语言中，不管对象还是字符串，内存都是在创建的时候自动分配内存，在不用了的时候自动释放掉，这个过程就是垃圾回收

**内存生命周期**

在所有编程语言中，内存管理的生命周期基本都是：分配，读写和释放，只是在高级语言中，我们大多时候只需要去读写部分的逻辑，但自动处理不代表不会出问题，代码的质量有问题的话，很容易导致内容泄露，也就是不用的内存一般没有被释放，如果加上循环等情况，非常容易导致浏览器内存爆满失去响应，所以注意内存管理是很重要的

内存管理中最麻烦的就是定位应该被释放的内存，在javascript中，一般是通过**garbage collector**来完成

**引用计数法**

最基础的垃圾回收算法是通过把没有被引用的内存做为应该释放的内容来处理

```javascript
var o = { a: 1 };
o = 1; // 不再有引用指向a，所以a被释放
```

可以看出，手动释放内存的常用方法是重新赋值，比如把对象赋值为null

但引用计数法无法应对闭包内的循环引用的情况：

```javascript
(function func() {
    var o = {};
    var oo = {};
    o.a = oo;
    oo.a = o; // o和oo都永远不会被释放，形成了内容泄露
    return 'true';
})();
```

**标记清除法**

使用这类算法的垃圾回收器会在目标内存不可触达时去掉

算法会首先找到所有全局对象，然后迭代遍历查找有全局引用的变量，从而区分出可触达和不可触达的变量，所有不可触达的对象都会被释放

相比之下，这类算法更加优秀，同时也解决了循环引用的问题，目前大部分的浏览器中都是采用这类算法