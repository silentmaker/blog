{"version":3,"sources":["webpack:///path---页面渲染问题总结-dd15e2d003c7c54395c0.js","webpack:///./.cache/json/页面渲染问题总结.json"],"names":["webpackJsonp","485","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","tags","categories","date","pathContext","slug","previous","fields","path","next"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,eAAAC,OAAA,aAA4CC,gBAAmBC,GAAA,uFAAAC,KAAA,+vKAAgqKC,aAAmVL,MAAA,WAAAM,MAAA,MAAAC,YAAA,MAAAC,KAAA,kBAA6EC,aAAgBC,KAAA,aAAAC,UAAgCC,QAAUF,KAAA,aAAmBL,aAAgBQ,KAAA,eAAAb,MAAA,UAAAM,MAAA,cAAAC,YAAA,QAAmFO,MAASF,QAAUF,KAAA,kBAAwBL,aAAgBQ,KAAA,wBAAAb,MAAA,eAAAM,MAAA,cAAAC,YAAA","file":"path---页面渲染问题总结-dd15e2d003c7c54395c0.js","sourcesContent":["webpackJsonp([46900025108153],{\n\n/***/ 485:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Elvin's Blog\",\"author\":\"Elvin Ma\"}},\"markdownRemark\":{\"id\":\"/Users/maxingcong/Code/blog/src/pages/页面渲染问题总结.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>很多性能优化比较关注于Page Load Time (PLT)，比如经典的雅虎14条中提到的合并请求和压缩静态资源等等，但除去网站加载的时间以外，用户大部分的时间是花在与页面的交互上</p>\\n<p>因此页面渲染的性能也是关键优化点，包括UI反馈和动画等，最终目标都是提供给用户60fps的体验，屏幕刷新的每一帧只有16ms的时间，任何超过这个时间的计算都会导致掉帧，而帧的生命周期中有很多影响因素，常见的问题可以分为以下几类：</p>\\n<h4>大范围的布局和样式失效 - Style Invalidation</h4>\\n<p>改变元素的class，或者通过js直接修改样式，或者CSS Transition和CSS Animation都会导致浏览器无效掉部分Render Tree，而性能问题的关键在于有多大范围的样式失效了</p>\\n<p>最糟糕的情况下，有可能整个document的样式都失效了，导致一帧内浏览器要重新计算全部样式，再加上这个情况持续地发生在某个动画的每一帧里，比如说滚动，那么掉帧将会十分严重，一般我们可以通过chrome devtool里的perfomance面板，记录分析一帧里的layout和recaculate style的用时来确定问题</p>\\n<p>对于这种问题，常用的方法主要有：</p>\\n<ul>\\n<li>尽量通过无需修改样式的方法来达成效果；</li>\\n<li>实在需要改变样式的情况下，让修改的层级越少越好，父节点的变化会导致子树的样式失效；</li>\\n<li>将动画的提升到同个layer，可以通过chrome devtool的layer面板查看页面的分层情况；</li>\\n</ul>\\n<h4>布局颠簸 - Layout Thrashing</h4>\\n<p>计算元素的分布位置是很消耗浏览器性能的，也就是常说的layout过程</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">for</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">var</span> p <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> p <span class=\\\"token operator\\\">&lt;</span> paragraphs<span class=\\\"token punctuation\\\">.</span>length<span class=\\\"token punctuation\\\">;</span> p<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> para <span class=\\\"token operator\\\">=</span> paragraphs<span class=\\\"token punctuation\\\">[</span>p<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">var</span> width <span class=\\\"token operator\\\">=</span> div<span class=\\\"token punctuation\\\">.</span>offsetWidth<span class=\\\"token punctuation\\\">;</span>\\n    para<span class=\\\"token punctuation\\\">.</span>style<span class=\\\"token punctuation\\\">.</span>left <span class=\\\"token operator\\\">=</span> width <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">'px'</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>比如这样在循环中重复地读和写影响layout的属性，这会导致每次读的时候，浏览要重新计算layout来得到最新的位置值</p>\\n<p>不过这个问题是很好发现的，在chrome中记录和分析帧的时候，如果看到黄色感叹号，并且带有forced synchronous layout的说明字样，就表示你的代码中有这样的问题，需要及时调整计算逻辑</p>\\n<h4>布局属性动画 - Animating Layout Properties</h4>\\n<p>如果你的动画中改变了width、height 或者 position 等属性，浏览器在实际的动画帧里会从layout布局开始计算，然后才是paint绘制和composite合成，整个过程是比较耗时的，这个时候如果还有一些其他js的计算逻辑，就会很容易产生掉帧</p>\\n<p>如果你的动画只修改了background、color或者shadow，那你的时间消耗就会变成仅用于paint和composite，而如果你只修改transform或者opacity，则浏览器只需要进行composite，最好的情况是你的动画能只发生在合成阶段， 一般这类变化都支持GPU支持，所以性能更佳</p>\\n<h4>绘制风暴 - Paint Storms</h4>\\n<p>这个问题与样式失效类似，都是因为不必要的渲染时间，区别是这类问题主要指的是paint过程的消耗，一般来说是因为修改了会导致重绘的属性，同时因为不合理的布局，导致重绘的区域几乎是整个屏幕，这点可能通过打开chrome devtool里rendering的show paint rectangles来确认</p>\\n<p>很多使用transform的动画有这个问题，因为fixed、transform都不一定能保证将动画区域提升为一个独立的层，常见的hack方法是translateZ(0) 或者 backface-visibility: hidden，当然最好的方法还是避免触发重绘</p>\\n<h4>绘制超载 - Expensive Paints</h4>\\n<p>有时候掉帧的原因仅仅是有特定某些帧的时间消耗过大，这类问题同样还是可以通过帧的记录分析来排查，最常见的一个情况是图片的缩放，特别是缩放绑定在了滚动事件的回调里，同时图片文件还很大的时候，帧的性能消耗就会很大</p>\\n<p>可以能能过打开rendering下面的enable continuous page repainting来帮助你找到这类问题，打开这个开关主要作用是让浏览器在每一帧都进行完整的重绘，从而让有绘制问题的帧更加明显</p>\\n<h4>事件监听超载 - Expensive Input Handlers</h4>\\n<p>有些时候用户的输入类事件监听器也会有性能问题，比如scrolls、touch、mouse 和 orientation事件，因为这类事情的触发频率有可能很高，如果一帧里事件回调函数要执行很多次，就会导致掉帧</p>\\n<p>最简单可行的方法是debounce事件回调，对于同一帧里的多次回调只安排一次执行：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">onScroll</span><span class=\\\"token punctuation\\\">(</span>evt<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    z<span class=\\\"token punctuation\\\">.</span>lastScrollY <span class=\\\"token operator\\\">=</span> window<span class=\\\"token punctuation\\\">.</span>scrollY<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 保存好需要的数据</span>\\n    <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>scheduledAnimationFrame<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">return</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 避免多次执行</span>\\n    scheduledAnimationFrame <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token function\\\">requestAnimationFrame</span><span class=\\\"token punctuation\\\">(</span>updatePage<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\nwindow<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">addEventListener</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'scroll'</span><span class=\\\"token punctuation\\\">,</span> onScroll<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<h4>动画撞上垃圾回收 - Garbage Collection in Animations</h4>\\n<p>一般来说GC会暂停主线程的所有工作直到垃圾回收完毕，而其本身耗时一直没有什么优化，并且从开发者角度说GC的发生实在是不好预测，如果它刚好发生的动画的一半，那就会导致动画的卡顿，chrome devtool里的memory profiler工具可以帮助你分析这类情况</p>\\n<p>要避免这个问题，通常要注意的就是尽量不要在动画过程中创建一堆新的对象，最理想的情况是在循环和动画中都只复用旧的对象来完成工作，越少创建对象，就越能减少撞上垃圾回收的概率</p>\",\"frontmatter\":{\"title\":\"页面渲染问题总结\",\"tags\":[\"性能\"],\"categories\":[\"编程\"],\"date\":\"May 25, 2018\"}}},\"pathContext\":{\"slug\":\"/页面渲染问题总结/\",\"previous\":{\"fields\":{\"slug\":\"/Babel笔记/\"},\"frontmatter\":{\"path\":\"/babel-notes\",\"title\":\"Babel笔记\",\"tags\":[\"Javascript\"],\"categories\":[\"编程\"]}},\"next\":{\"fields\":{\"slug\":\"/用D3力导向图做思维导图/\"},\"frontmatter\":{\"path\":\"/d3-force-and-mindmap\",\"title\":\"用D3力导向图做思维导图\",\"tags\":[\"javascript\"],\"categories\":[\"dev\"]}}}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---页面渲染问题总结-dd15e2d003c7c54395c0.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Elvin's Blog\",\"author\":\"Elvin Ma\"}},\"markdownRemark\":{\"id\":\"/Users/maxingcong/Code/blog/src/pages/页面渲染问题总结.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>很多性能优化比较关注于Page Load Time (PLT)，比如经典的雅虎14条中提到的合并请求和压缩静态资源等等，但除去网站加载的时间以外，用户大部分的时间是花在与页面的交互上</p>\\n<p>因此页面渲染的性能也是关键优化点，包括UI反馈和动画等，最终目标都是提供给用户60fps的体验，屏幕刷新的每一帧只有16ms的时间，任何超过这个时间的计算都会导致掉帧，而帧的生命周期中有很多影响因素，常见的问题可以分为以下几类：</p>\\n<h4>大范围的布局和样式失效 - Style Invalidation</h4>\\n<p>改变元素的class，或者通过js直接修改样式，或者CSS Transition和CSS Animation都会导致浏览器无效掉部分Render Tree，而性能问题的关键在于有多大范围的样式失效了</p>\\n<p>最糟糕的情况下，有可能整个document的样式都失效了，导致一帧内浏览器要重新计算全部样式，再加上这个情况持续地发生在某个动画的每一帧里，比如说滚动，那么掉帧将会十分严重，一般我们可以通过chrome devtool里的perfomance面板，记录分析一帧里的layout和recaculate style的用时来确定问题</p>\\n<p>对于这种问题，常用的方法主要有：</p>\\n<ul>\\n<li>尽量通过无需修改样式的方法来达成效果；</li>\\n<li>实在需要改变样式的情况下，让修改的层级越少越好，父节点的变化会导致子树的样式失效；</li>\\n<li>将动画的提升到同个layer，可以通过chrome devtool的layer面板查看页面的分层情况；</li>\\n</ul>\\n<h4>布局颠簸 - Layout Thrashing</h4>\\n<p>计算元素的分布位置是很消耗浏览器性能的，也就是常说的layout过程</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">for</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">var</span> p <span class=\\\"token operator\\\">=</span> <span class=\\\"token number\\\">0</span><span class=\\\"token punctuation\\\">;</span> p <span class=\\\"token operator\\\">&lt;</span> paragraphs<span class=\\\"token punctuation\\\">.</span>length<span class=\\\"token punctuation\\\">;</span> p<span class=\\\"token operator\\\">++</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">var</span> para <span class=\\\"token operator\\\">=</span> paragraphs<span class=\\\"token punctuation\\\">[</span>p<span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token keyword\\\">var</span> width <span class=\\\"token operator\\\">=</span> div<span class=\\\"token punctuation\\\">.</span>offsetWidth<span class=\\\"token punctuation\\\">;</span>\\n    para<span class=\\\"token punctuation\\\">.</span>style<span class=\\\"token punctuation\\\">.</span>left <span class=\\\"token operator\\\">=</span> width <span class=\\\"token operator\\\">+</span> <span class=\\\"token string\\\">'px'</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span></code></pre>\\n      </div>\\n<p>比如这样在循环中重复地读和写影响layout的属性，这会导致每次读的时候，浏览要重新计算layout来得到最新的位置值</p>\\n<p>不过这个问题是很好发现的，在chrome中记录和分析帧的时候，如果看到黄色感叹号，并且带有forced synchronous layout的说明字样，就表示你的代码中有这样的问题，需要及时调整计算逻辑</p>\\n<h4>布局属性动画 - Animating Layout Properties</h4>\\n<p>如果你的动画中改变了width、height 或者 position 等属性，浏览器在实际的动画帧里会从layout布局开始计算，然后才是paint绘制和composite合成，整个过程是比较耗时的，这个时候如果还有一些其他js的计算逻辑，就会很容易产生掉帧</p>\\n<p>如果你的动画只修改了background、color或者shadow，那你的时间消耗就会变成仅用于paint和composite，而如果你只修改transform或者opacity，则浏览器只需要进行composite，最好的情况是你的动画能只发生在合成阶段， 一般这类变化都支持GPU支持，所以性能更佳</p>\\n<h4>绘制风暴 - Paint Storms</h4>\\n<p>这个问题与样式失效类似，都是因为不必要的渲染时间，区别是这类问题主要指的是paint过程的消耗，一般来说是因为修改了会导致重绘的属性，同时因为不合理的布局，导致重绘的区域几乎是整个屏幕，这点可能通过打开chrome devtool里rendering的show paint rectangles来确认</p>\\n<p>很多使用transform的动画有这个问题，因为fixed、transform都不一定能保证将动画区域提升为一个独立的层，常见的hack方法是translateZ(0) 或者 backface-visibility: hidden，当然最好的方法还是避免触发重绘</p>\\n<h4>绘制超载 - Expensive Paints</h4>\\n<p>有时候掉帧的原因仅仅是有特定某些帧的时间消耗过大，这类问题同样还是可以通过帧的记录分析来排查，最常见的一个情况是图片的缩放，特别是缩放绑定在了滚动事件的回调里，同时图片文件还很大的时候，帧的性能消耗就会很大</p>\\n<p>可以能能过打开rendering下面的enable continuous page repainting来帮助你找到这类问题，打开这个开关主要作用是让浏览器在每一帧都进行完整的重绘，从而让有绘制问题的帧更加明显</p>\\n<h4>事件监听超载 - Expensive Input Handlers</h4>\\n<p>有些时候用户的输入类事件监听器也会有性能问题，比如scrolls、touch、mouse 和 orientation事件，因为这类事情的触发频率有可能很高，如果一帧里事件回调函数要执行很多次，就会导致掉帧</p>\\n<p>最简单可行的方法是debounce事件回调，对于同一帧里的多次回调只安排一次执行：</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-javascript\\\"><code class=\\\"language-javascript\\\"><span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">onScroll</span><span class=\\\"token punctuation\\\">(</span>evt<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    z<span class=\\\"token punctuation\\\">.</span>lastScrollY <span class=\\\"token operator\\\">=</span> window<span class=\\\"token punctuation\\\">.</span>scrollY<span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 保存好需要的数据</span>\\n    <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>scheduledAnimationFrame<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">return</span><span class=\\\"token punctuation\\\">;</span> <span class=\\\"token comment\\\">// 避免多次执行</span>\\n    scheduledAnimationFrame <span class=\\\"token operator\\\">=</span> <span class=\\\"token boolean\\\">true</span><span class=\\\"token punctuation\\\">;</span>\\n    <span class=\\\"token function\\\">requestAnimationFrame</span><span class=\\\"token punctuation\\\">(</span>updatePage<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\nwindow<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">addEventListener</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'scroll'</span><span class=\\\"token punctuation\\\">,</span> onScroll<span class=\\\"token punctuation\\\">,</span> <span class=\\\"token boolean\\\">false</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span></code></pre>\\n      </div>\\n<h4>动画撞上垃圾回收 - Garbage Collection in Animations</h4>\\n<p>一般来说GC会暂停主线程的所有工作直到垃圾回收完毕，而其本身耗时一直没有什么优化，并且从开发者角度说GC的发生实在是不好预测，如果它刚好发生的动画的一半，那就会导致动画的卡顿，chrome devtool里的memory profiler工具可以帮助你分析这类情况</p>\\n<p>要避免这个问题，通常要注意的就是尽量不要在动画过程中创建一堆新的对象，最理想的情况是在循环和动画中都只复用旧的对象来完成工作，越少创建对象，就越能减少撞上垃圾回收的概率</p>\",\"frontmatter\":{\"title\":\"页面渲染问题总结\",\"tags\":[\"性能\"],\"categories\":[\"编程\"],\"date\":\"May 25, 2018\"}}},\"pathContext\":{\"slug\":\"/页面渲染问题总结/\",\"previous\":{\"fields\":{\"slug\":\"/Babel笔记/\"},\"frontmatter\":{\"path\":\"/babel-notes\",\"title\":\"Babel笔记\",\"tags\":[\"Javascript\"],\"categories\":[\"编程\"]}},\"next\":{\"fields\":{\"slug\":\"/用D3力导向图做思维导图/\"},\"frontmatter\":{\"path\":\"/d3-force-and-mindmap\",\"title\":\"用D3力导向图做思维导图\",\"tags\":[\"javascript\"],\"categories\":[\"dev\"]}}}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/页面渲染问题总结.json\n// module id = 485\n// module chunks = 46900025108153"],"sourceRoot":""}