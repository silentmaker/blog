webpackJsonp([57227495939072],{489:function(n,t){n.exports={data:{site:{siteMetadata:{title:"Elvin's Blog",author:"Elvin Ma"}},markdownRemark:{id:"/Users/maxingcong/Code/blog/src/pages/小程序基本原理.md absPath of file >>> MarkdownRemark",html:'<p><strong>运行环境</strong></p>\n<ul>\n<li>\n<p>在iOS上，小程序的javascript代码是运行在 JavaScriptCore 中</p>\n</li>\n<li>\n<p>在Android上，小程序的javascript代码是通过X5内核来解析</p>\n</li>\n<li>\n<p>在 开发工具上， 小程序的javascript代码是运行于 nwjs（原node-webkit）</p>\n</li>\n</ul>\n<p>nw.js 与 Electron 类似，两者都同时提供了 Broswer 和 Node.js 的 runtime 环境，使得开发者即可以编写和操作DOM，同时可以借助 Node.js 来访问操作系统原生API的能力</p>\n<p><strong>通信原理</strong></p>\n<p>小程序的 UI 经由 WKWebView 来渲染，API调用通过 JSBridge 将逻辑结果传递到 webview 做渲染，可以类似地参考 React-Native的实现原理：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/blog/static/rn-communication-2bcb54a9db3431b5b644bada6c8c444a-eae6d.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 63.12384473197782%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsSAAALEgHS3X78AAAClElEQVQ4yz2TWW8TMRDH8/2/ABIPvPHAA4cEElAKBSEQFUnpTZK2adPm7GZP7+H1rvfH2GmxNPJ47Ln+/3GvqDSlbkhVgSoqr5faYOqaohCbUqRpSp7n1LXxd+6de59kOUVVex+ta7mv6RXhHJsuWF4es7kdYrMlJl35AEmScH8fsFgsiKKIIs/82/huyPziiJvzPlV4R5fOKbIILQl7ZvQeTp/D6LXIGzgR/fIDKi9oG8PjMqYhT0K64Vv4+xLGr0Tk/Uj0g2cUyyF129GLVUkQK7KiJsk1m0ShKmkrS+VcE1UQlR1hVpJnCdz+wCzPmMYdi8Rwl1iWQUwah5JUKvw+0excdny7gc+Tzuv7t4KVijmc1excwacJ9G8EryQQ5QnZyTt2r+HXtGH3qmO8UJR5usVQa40Tay1t2wgRud8dEWVZir2Vc0suRETBUuB5QTLc4+OF5ed1zYdxw3UgZKrUk9brGg1OaD1WztkFCsPQM+yyuoRppnzArv8UM/7InYKZ4DFLO7Kq9RD5CkcrLa1pLoKWRoJtK209yw6Tx+WyF1lMdy7kTb/Cqo+d7MF64MlzHXkMD2cVhyshd2X9LLnq3Pw5qeRspPBaJC8rbzOt9XPoRioIAg+PC+QC+gqx1UMN3f9qlJvBaMOp9PVFwP8ipBxMC6Jwwx8h6tet5fcCvk0azoUnbEPyWOForRmFMIkEymbbssuUJREXq5L9OezPhIt5hUpjrjYtx2t5H1pGQcfpPWyUecBQAg6mOf1Zy9HcCG6FtOy+27bC8TxlMG8ZzBrOZvIF4w2jZSk2y+W64u+y8veOnLJQ8lOk5UbLaJiKtq54HCEnTSPY1LLXpRcj9+63NLJbbxMf8bNG7vTW13X2DzAm2k13RUX+AAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="react native theory"\n        title=""\n        src="/blog/static/rn-communication-2bcb54a9db3431b5b644bada6c8c444a-fb8a0.png"\n        srcset="/blog/static/rn-communication-2bcb54a9db3431b5b644bada6c8c444a-1a291.png 148w,\n/blog/static/rn-communication-2bcb54a9db3431b5b644bada6c8c444a-2bc4a.png 295w,\n/blog/static/rn-communication-2bcb54a9db3431b5b644bada6c8c444a-fb8a0.png 590w,\n/blog/static/rn-communication-2bcb54a9db3431b5b644bada6c8c444a-526de.png 885w,\n/blog/static/rn-communication-2bcb54a9db3431b5b644bada6c8c444a-eae6d.png 1082w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><strong>文件结构</strong></p>\n<ul>\n<li>\n<p>App由app.js、app.json、app.wxss 组成</p>\n</li>\n<li>\n<p>Page由page.js、page.json、page.wxss 和 page.wxml 组成</p>\n</li>\n</ul>\n<h3>生命周期</h3>\n<p><strong>App</strong></p>\n<table>\n<thead>\n<tr>\n<th>钩子</th>\n<th>描述</th>\n<th>时间点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onLaunch</td>\n<td>小程序初始化</td>\n<td>当初始化完成时调用，全局只触发一次</td>\n</tr>\n<tr>\n<td>onShow</td>\n<td>小程序显示</td>\n<td>启动或从后台进入前台展示时触发</td>\n</tr>\n<tr>\n<td>onHide</td>\n<td>小程序隐藏</td>\n<td>从前台进入后台时触发</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Page</strong></p>\n<table>\n<thead>\n<tr>\n<th>钩子</th>\n<th>描述</th>\n<th>时间点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onLoad</td>\n<td>页面加载</td>\n<td>一个页面只调用一次</td>\n</tr>\n<tr>\n<td>onShow</td>\n<td>页面显示</td>\n<td>每次打开页面都会触发</td>\n</tr>\n<tr>\n<td>onReady</td>\n<td>页面初次渲染完成</td>\n<td>一个页面只调用一次，且表示页面已可交互，可进行页面设置，如 \n<em>wx.setNavigationBarTitle</em></td>\n</tr>\n<tr>\n<td>onHide</td>\n<td>页面隐藏</td>\n<td>当 \n<em>wx.navigateTo</em>\n 或底部Tab切换时触发</td>\n</tr>\n<tr>\n<td>onUnload</td>\n<td>页面卸载</td>\n<td>当 \n<em>wx.redirectTo</em>\n 或 \n<em>wx.navigateBack</em>\n 时触发</td>\n</tr>\n</tbody>\n</table>\n<h3>两类线程</h3>\n<ul>\n<li>界面线程（View Thread） - 负责界面渲染</li>\n<li>服务线程（Appservice Thread） - 负责数据，服务处理</li>\n</ul>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/blog/static/mp-thread-2c5245e41bb67471703f6aa7f167abf0-bb6bf.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 153.17220543806647%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAIAAABoLHqZAAAACXBIWXMAAAsSAAALEgHS3X78AAAFXUlEQVQ4y21VWWwTVxQdVUKitOpH099KVO0PRS20bBUVP7TQfiKKKgFtpaoCGiEEH1CEI6BpCyJOSJwVW4Gw2glNgISYxtkTIA1kaRw7IQQnthMvcezx7PNmH/eOnRjS5uloNPNmzrvvnnvuG4xhmLGxsUgkkkoPPT2y93ANhUJer5dl2exMdmAcw7947vNP+QVeUGQlTVoChmb9U4HQTBjxgiRKmqoBMq8wjkYMxVJJmqX5ucjctG86Go5mXwMEFrEkyxA0z/AzwRn4IDYXWyAzHBGZmwmF/SST4HkegquKurCt9BchkvbOREYDIV8MJylaEgSaoiRRhBywcNIzNtvtDXYFEsOyLKmKBnye43VNB8AKnYG5qscea5/37sQsi1BKlRFN8BSuSAL2LNjZ+tTWNlg9Mu2EQBAWmHgcZygG8Ujkeceo72yPO7/Xc9nt59JkjkwgOqkpAhaIDYxMOd3+vyZmH9I0BRyKoBiaoUhKkmSIfMXjP9LtPdrjLRry0Swri0CMI5pSFRHjeZwVcAYlODEZCYcnJyaDgSAkDzQtve2a0elDzf25D56Y/36GYD1JEmU5UzPMPd3cNVjTM3h1aPIOSeGiIMoS5C6D4JmiGuSmR7nOPnOfV01PZWuNtbnL6nrz6npMriEzKAVTIBiRJCBzJS37ZU/g547Rw50e86BP0bUl5O4xm3P4gnO4oMNdJst8+p2eMROQFVFqHPeXPpkofzphH51meF4UBIamFcWQA+vyWu8Pnge0j5RmIhv56Avrw/0sg14QyEciPyUoUD4Jsck4m0woIsKc/ZZb7SZ7R55rqFhWkBE3S06jzReu9wbvjgcbxwMkzymyyHOsIom6pmLdXqtz4DygfcSyEDm1RJV9t1o3W+q2VdZvv3QnQtIpiJ1Vu3e8umW4ENA5WiFBznoKfAKayTLkZeA7R/u6otpNJX9+ZWtKcOhlb4G37z85V9Ny4Krr0O3ukwxLyKKSiCeikSj0ENgTSg3kjwtrNxXf3mltjP+HXNOSe6J84y/lm8sb9iqqAJPgSo7lVFWFUoPg+24++DDf9mnBtZ22BbK22PNYw6PTFU17K5v232w/JkqcpurgTWg6HMdh/9An+x0tay/e2FBiz0bOuAf42O0eU4F9l9m++0pLLmzbaGAkZI0Nj/trXWuLb2ywOCDnCMlAS/IIkSTFMqyRc7XzQLXzYP1Dk1GqxZT0xVJlyBstji8v3ZsMRWiSTOA4HF6yLGO9YzbXcKHrH0PtBYel6/x/8g7rvSgNJ5nKkoTIMilNgTpXOQfOAQyHyWg5MuR8HXIG8jwLq6sCx8qIUxUJ6/ZUNQ+cazbIliWRF02yp/TaulMXt5y1fP5r2VQ4ypAU1JIgwGw89nC8unWkCACrADmjNoGnuyptkl1m6+qDpjVHzmwxFb4IhDiawRM4HKmKomCNffmX7v9obf7J0XWCZUlN0aEf52PzcMoa8TV9d5Ht3QMnPzh8+rO8ohhBQ8vSeFygCV2VsPpek9mx2+zYc73tiLScYN+U1Lx/7Pc1x89vPWOJJqmUpiKWlRDsSwS1rS3DFwCdRj8vI9j39tatpXXbqxp2WO9ECErg+VhsXkCiIqtYh7uiqf83gGvo4vKlsrd+VHBrY3HtF5UNgbm4iBBBENA3hj37fdXtnoI2T8Hj55UvTfIK+YeG3vWldzdXNH1d02LYUxHpxDyXTEC1MPuDP6rqjlbWHr3WmCeInEHWXiXr35bdXHOicN2pkm35lbPzxgFCUaQkIU2TsdWr33t95aqVK1blvJ2DJxIvyYvXT9avX4G99tYbb76TkxMJGT9T40+WHv8CDkweH9UsGoUAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="mini program threads"\n        title=""\n        src="/blog/static/mp-thread-2c5245e41bb67471703f6aa7f167abf0-fb8a0.png"\n        srcset="/blog/static/mp-thread-2c5245e41bb67471703f6aa7f167abf0-1a291.png 148w,\n/blog/static/mp-thread-2c5245e41bb67471703f6aa7f167abf0-2bc4a.png 295w,\n/blog/static/mp-thread-2c5245e41bb67471703f6aa7f167abf0-fb8a0.png 590w,\n/blog/static/mp-thread-2c5245e41bb67471703f6aa7f167abf0-bb6bf.png 662w"\n        sizes="(max-width: 590px) 100vw, 590px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p><strong>界面线程的四类状态</strong></p>\n<ol>\n<li>初始化状态：初始化界面线程所需要的工作，包括工作机制，基本和我们开发者没有关系，等初始化完毕就向 “服务线程”发送初始化完毕信号，然后进入等待传回初始化数据状态。</li>\n<li>首次渲染状态：收到“服务线程”发来的初始化数据后（就是 json和js中的data数据），就开始渲染小程序界面，渲染完毕后，发送“首次渲染完毕信号”给服务线程，并将页面展示给用户。</li>\n<li>持续渲染状态：此时界面线程继续一直等待“服务线程”通过this.setdata()函数发送来的界面数据，只要收到就重新局部渲染，也因此只要更新数据并发送信号，界面就自动更新。</li>\n<li>结束状态</li>\n</ol>\n<p><strong>服务线程五状态</strong></p>\n<ol>\n<li>初始化状态：无需和其他模块交流，跟小程序开发也没多大关联，此阶段就是启动服务线程所需的基本功能，比如信号发送模块。系统的初始化工作完毕，就调用自定义的onload和onshow，然后等待界面线程的“界面线程初始化完成”信号。onload是只会首次渲染的时候执行一次，onshow是每次界面切换都会执行</li>\n<li>等待激活状态：接收到“界面线程初始化完成”信号后，将初始化数据发送给“界面线程”，等待界面线程完成初次渲染</li>\n<li>激活状态：收到界面线程发送来的“首次渲染完成”信号后，就进入激活状态既程序的正常运行状态，并调用自定义的onReady()函数。此状态下就可以通过 this.setData 函数发送界面数据给界面线程进行局部渲染，更新页面</li>\n<li>后台运行状态：如果界面进入后台，服务线程就进入后台运行状态，从目前的官方解读来说，这个状态挺奇怪的，和激活状态是相同的，也可以通过setdata函数更新界面的</li>\n<li>结束状态：页面被回收或者销毁、应用被系统回收、销毁时触发</li>\n</ol>\n<h3>更新</h3>\n<p>小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上</p>',frontmatter:{title:"小程序基本原理",tags:null,categories:["编程"],date:"May 01, 2017"}}},pathContext:{slug:"/小程序基本原理/",previous:{fields:{slug:"/内存管理与垃圾回收/"},frontmatter:{path:"/js-memory-management",title:"内存管理与垃圾回收",tags:["Javascript"],categories:["编程"]}},next:{fields:{slug:"/使用Proxy监听对象/"},frontmatter:{path:"/using-proxy-to-monitor-object",title:"使用Proxy监听对象",tags:["Javascript"],categories:["编程"]}}}}}});
//# sourceMappingURL=path---小程序基本原理-8af28029efaeee258108.js.map