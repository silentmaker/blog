{"version":3,"sources":["webpack:///path---categories-编程-adec43c86c7089b42d51.js","webpack:///./.cache/json/categories-编程.json"],"names":["webpackJsonp","448","module","exports","data","site","siteMetadata","title","allMarkdownRemark","edges","node","excerpt","fields","slug","frontmatter","date","pathContext","category"],"mappings":"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","file":"path---categories-编程-adec43c86c7089b42d51.js","sourcesContent":["webpackJsonp([260249089781156],{\n\n/***/ 448:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Elvin's Blog\"}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"excerpt\":\"…\",\"fields\":{\"slug\":\"/IntersectionObserver和懒加载优化/\"},\"frontmatter\":{\"date\":\"20 February, 2019\",\"title\":\"IntersectionObserver和懒加载优化\"}}},{\"node\":{\"excerpt\":\"PM2，Production Process Manager，是一个很好用的进程管理器，有很多优秀的特性，比如平滑的服务重启、直观的进程管理和日志监控、零配置负载均衡和友好的多服务器部署 以下是PM2的一些常用命令 模块扩展 \\npm2支持第三方扩展，比如常用的log rotate…\",\"fields\":{\"slug\":\"/PM2常用命令/\"},\"frontmatter\":{\"date\":\"26 December, 2018\",\"title\":\"PM2常用命令\"}}},{\"node\":{\"excerpt\":\"1xx的状态码表示临时响应 100 “continue” 用于让客户端得知服务端没有拒绝请求，可以发送正式的请求体，请求Header一般包含Expect 101 “switching protocols” 服务端按客户端请求变更协议，请求Header一般包含Upgrade 10…\",\"fields\":{\"slug\":\"/常见状态码和使用场景/\"},\"frontmatter\":{\"date\":\"22 December, 2018\",\"title\":\"常见架构模式笔记\"}}},{\"node\":{\"excerpt\":\"无事总结了下自己习惯用的Vue项目文件结构 清晰的项目结构有助于项目增长过程中的代码规范和质量管理，合理的项目结构能帮助新人更快地把握项目代码，自己开发时思路也会更加清晰，复用性的代码要支持按模块引入，减少多余的打包体积\",\"fields\":{\"slug\":\"/Vue项目结构总结/\"},\"frontmatter\":{\"date\":\"03 December, 2018\",\"title\":\"Vue项目结构总结\"}}},{\"node\":{\"excerpt\":\"Koa是Express的维护者们基于更简洁稳定和更充分利用Async/Await异步模式的目标重写的web框架，不自带任何中间件，Koa本身可以看作对http库的一层封装，一个Koa应用的开发可以理解为一系列中间件的组合 级联中间件 当中间件用异步方式调用next…\",\"fields\":{\"slug\":\"/Koa入门笔记/\"},\"frontmatter\":{\"date\":\"29 November, 2018\",\"title\":\"Koa入门笔记\"}}},{\"node\":{\"excerpt\":\"之前看VueConf，有一个Lightning Talk的内容挺有趣的，基本思路大概就是，Vue组件不一定要用来渲染HTML，或者说用组件这种声明式的写法可以做一些别的事情 下面提到的在Github上可以找到对应的项目： vue-motion 、 vue-promised…\",\"fields\":{\"slug\":\"/用Vue写不是组件的组件/\"},\"frontmatter\":{\"date\":\"22 November, 2018\",\"title\":\"\"}}},{\"node\":{\"excerpt\":\"Rollup 是一个和 Webpack 类似的 JavaScript 模块打包工具，不同的是 Rollup 默认对模块使用新的标准化格式，这些标准都是包含在 JavaScript 的 ES6 版本中的，而非以前的特殊解决方案，比如 CommonJS 和 AMD，ES…\",\"fields\":{\"slug\":\"/Rollup的基本使用/\"},\"frontmatter\":{\"date\":\"26 October, 2018\",\"title\":\"Rollup的基本使用\"}}},{\"node\":{\"excerpt\":\"SFC，Single File Component，Vue所谓的单文件组件，有时你可能需要快捷地把组件发布到npm给其他人使用，国外有开发者在VueConf分享了一套简便的模板，后来发现Vue Cookbook也已经采纳为一种推荐做法了 项目的地址是： vue-sfc…\",\"fields\":{\"slug\":\"/快捷发布Vue的单文件组件/\"},\"frontmatter\":{\"date\":\"02 October, 2018\",\"title\":\"快捷发布Vue的单文件组件\"}}},{\"node\":{\"excerpt\":\"CDN(Content Delivery Network, 内容分发网络) 是用于改善网络性能的一种解决方案 CDN…\",\"fields\":{\"slug\":\"/CDN基础总结/\"},\"frontmatter\":{\"date\":\"26 September, 2018\",\"title\":\"CDN基础总结\"}}},{\"node\":{\"excerpt\":\"Canvas性能优化的总体思路——在每一帧中，尽可能减少调用渲染相关 API 的次数，通常要以计算的复杂化为代价，尽可能调用渲染开销较低的 API，或者尽可能以渲染开销较低的方式调用渲染相关 API context的赋值开销 Canvas…\",\"fields\":{\"slug\":\"/Canvas性能优化总结/\"},\"frontmatter\":{\"date\":\"20 September, 2018\",\"title\":\"Canvas性能优化总结\"}}},{\"node\":{\"excerpt\":\"维基百科定义中，架构模式是指：在给定环境中，对常见的软件架构问题的一种通用的、可复用的解决方案，架构模式与设计模式很相似，只是边界范围更明确 Layered Pattern 层级模式 Client-Sever Pattern 客户端-服务端模式 Master-Slave…\",\"fields\":{\"slug\":\"/常见架构模式笔记/\"},\"frontmatter\":{\"date\":\"22 August, 2018\",\"title\":\"常见架构模式笔记\"}}},{\"node\":{\"excerpt\":\"在之前的博客里我提到过用Canvas实现天气效果，后面我偶然用Chrome的Performance Monitor查看这个页面的内存情况，发现切换几次天气后，CPU占用率从20%升到了90%，断定有性能效果，初步猜测是有内部自动GC…\",\"fields\":{\"slug\":\"/性能问题排查: bind(this)/\"},\"frontmatter\":{\"date\":\"21 August, 2018\",\"title\":\"性能问题排查: bind(this)\"}}},{\"node\":{\"excerpt\":\"最近在 Paul Levis 的 Youtube 频道更新了他关于如何实现下雪效果的视频，心血来潮就将他的做法拓展了一下，简单实现了下 Rainy、Snowy、Starry 和 Cloudy 四种天气 Demo 的传送门在这里： Weather Canvas…\",\"fields\":{\"slug\":\"/用Canvas实现简单的天气效果/\"},\"frontmatter\":{\"date\":\"11 August, 2018\",\"title\":\"用Canvas实现简单的天气效果\"}}},{\"node\":{\"excerpt\":\"代码分片指的是在构建打包的过程中，把代码分成片段打包为块文件的过程，并在页面需要时加载 现在Webpack推荐的文件打包后的大小标准是：js < 200kb，css < 100kb，coverage > 90% Coverage…\",\"fields\":{\"slug\":\"/代码分片的常见场景/\"},\"frontmatter\":{\"date\":\"06 August, 2018\",\"title\":\"代码分片的常见场景\"}}},{\"node\":{\"excerpt\":\"RAIL is a User-centric performance model that breaks down the user’s experience into key actions. Every web app has four distinct aspects to…\",\"fields\":{\"slug\":\"/RAIL性能模型笔记/\"},\"frontmatter\":{\"date\":\"26 July, 2018\",\"title\":\"RAIL性能模型笔记\"}}},{\"node\":{\"excerpt\":\"Redux 创建Store 使用Store React Redux 通过Provider注入store 状态映射 简化版本如下 合并Reducers Redux Middleware 创建中间件 应用中间件 其他 Redux Documentation\",\"fields\":{\"slug\":\"/Redux基础/\"},\"frontmatter\":{\"date\":\"26 July, 2018\",\"title\":\"Redux基础\"}}},{\"node\":{\"excerpt\":\"Everything is an element. Concepts Polymer lets you build encapsulated, reusable  Web Components  that work just like standard HTML elements…\",\"fields\":{\"slug\":\"/Ploymer入门/\"},\"frontmatter\":{\"date\":\"26 July, 2018\",\"title\":\"Ploymer入门\"}}},{\"node\":{\"excerpt\":\"Javascript是一门天生有异步基因的语言，这是由于事件循环和浏览器的交互机制等原因决定的 对于异步流程的控制，我们经历了从最早的 callback，然后是 Promise，到现在的Async/Await和Generator，方式变得越来越灵活 Async/Await…\",\"fields\":{\"slug\":\"/异步流程控制与错误处理/\"},\"frontmatter\":{\"date\":\"12 July, 2018\",\"title\":\"异步流程控制与错误处理\"}}},{\"node\":{\"excerpt\":\"假设有一个业务场景是这样的，根据一个微博或者其他社交媒体的图片搜索接口，不停地切换展示图片，比如说不断切换微博有关于猫的图片，每张图片只展示一次，常见的思路就是分页+轮询 对于这种生成不间断的数据流的模式，其实也可以用迭代器和generator的思路来做： switchCat…\",\"fields\":{\"slug\":\"/Generator与asyncIterator/\"},\"frontmatter\":{\"date\":\"26 June, 2018\",\"title\":\"Generator与asyncIterator\"}}},{\"node\":{\"excerpt\":\"Worker  是在 Javascript 中实现多线程的一种方法，通常用于进行耗时/次要的任务，可以提高计算速度，并且达到不阻塞UI的目的 在 Web Workers API 中，Worker可以分为  dedicated Woker ， SharedWorker…\",\"fields\":{\"slug\":\"/Web Worker笔记/\"},\"frontmatter\":{\"date\":\"26 June, 2018\",\"title\":\"Web Workers笔记\"}}},{\"node\":{\"excerpt\":\"很多性能优化比较关注于Page Load Time (PLT)，比如经典的雅虎14条中提到的合并请求和压缩静态资源等等，但除去网站加载的时间以外，用户大部分的时间是花在与页面的交互上 因此页面渲染的性能也是关键优化点，包括UI反馈和动画等，最终目标都是提供给用户60fps…\",\"fields\":{\"slug\":\"/页面渲染问题总结/\"},\"frontmatter\":{\"date\":\"25 May, 2018\",\"title\":\"页面渲染问题总结\"}}},{\"node\":{\"excerpt\":\"Babel 是 Javascript 的转译工具，可以帮助开发者在写代码的时候可以使用更先进的语法和API，并在运行前转译为更具兼容性的语法 确立  ECMAScript  标准语法的五阶段: Stage 0：strawman - “稻草人” Stage 1：proposal…\",\"fields\":{\"slug\":\"/Babel笔记/\"},\"frontmatter\":{\"date\":\"20 May, 2018\",\"title\":\"Babel笔记\"}}},{\"node\":{\"excerpt\":\"…\",\"fields\":{\"slug\":\"/前端工程师的一专多长/\"},\"frontmatter\":{\"date\":\"17 May, 2018\",\"title\":\"前端工程师的一专多长\"}}},{\"node\":{\"excerpt\":\"后端监控  - 采集服务器以及链路上各种中间件的数据\\n 前端监控  - 运行在用户终端上的代码 最简实现：通过 window.onerror 采集到所有的未捕获异常，并通过 new Image() 的方式构造一个 404 的 HTTP 请求，最后在服务端实时过滤 access…\",\"fields\":{\"slug\":\"/前端监控系统总结/\"},\"frontmatter\":{\"date\":\"06 April, 2018\",\"title\":\"前端监控系统总结\"}}},{\"node\":{\"excerpt\":\"编程范式  是指一种基于基本原则来思考如何构建软件的方式，常见的范式还有  面向对象编程 、 面向过程编程  和  函数式编程 函数式编程 （Functional Programming…\",\"fields\":{\"slug\":\"/函数式编程基本概念/\"},\"frontmatter\":{\"date\":\"06 March, 2018\",\"title\":\"函数式编程基本概念\"}}},{\"node\":{\"excerpt\":\"P5.js P5.js源于Processing，它们原来的出发点都是使图形编程可供艺术家，设计师，教育工作者和初学者使用，而Processing是很多年前提出的技术了，其实现其实是使用regex将Java转换为JS，而P5.js则是以原生JavaScript…\",\"fields\":{\"slug\":\"/P5.js和贪吃蛇游戏/\"},\"frontmatter\":{\"date\":\"02 February, 2018\",\"title\":\"P5.js和贪吃蛇游戏\"}}},{\"node\":{\"excerpt\":\"首先需要购置一台VPN用主机和自用域名，将域名 DOMAIN 的 A/AAAA 记录指向该主机，安装nginx并启动，主机推荐腾讯云香港区域的S1系列（CentOS） Let’s Encrypt 为了内容传输的隐密性，可以采用 Let’s Encrypt…\",\"fields\":{\"slug\":\"/用OpenConnectSever搭建VPN/\"},\"frontmatter\":{\"date\":\"26 January, 2018\",\"title\":\"OpenConnectSever搭建VPN总结\"}}},{\"node\":{\"excerpt\":\"从最简单的方式开始 通常方法我们会提取到prototype中复用以节约内存 但是这样并没有达到真正私有变量的目的，只是单纯地用了命名惯例而已，于是可以算要用一个闭包才形有私有作用域 但这些多个Person类间的name…\",\"fields\":{\"slug\":\"/如何实现javascript的私有变量/\"},\"frontmatter\":{\"date\":\"26 January, 2018\",\"title\":\"如何实现javascript的私有变量\"}}},{\"node\":{\"excerpt\":\"大前端，简而言之，就是统一三端的开发( Web, Desktop, Mobile) 现在前端涉及的领域十分广泛，各种技术层出不穷—— 在多媒体领域，比如基于 WebRTC 的语音视频通话，基于P2P + CDN的流建媒体分发网络技术 在图形学领域，比如AR / VR…\",\"fields\":{\"slug\":\"/关于大前端/\"},\"frontmatter\":{\"date\":\"26 December, 2017\",\"title\":\"关于大前端\"}}},{\"node\":{\"excerpt\":\"箭头函数用起来比较潮，但是原来的函数写法依旧有其用处，毕竟这两者还有很多不等价的情况 箭头函数缺失的东西 没有自己的 this ，其this是由执行时在当前scope中继承的 没有 prototype 属性，所以用于new，如 没有 arguments 对象，也没有 new…\",\"fields\":{\"slug\":\"/箭头函数总结/\"},\"frontmatter\":{\"date\":\"26 December, 2017\",\"title\":\"箭头函数总结\"}}},{\"node\":{\"excerpt\":\"从命令行打开当前目录 按 Shift + Command + P，调出Command Panel 输入并选择 Install ‘code’ command in PATH，如果没有这条命令的话，则有可能是已经添加过了，然后再打开terminal里执行code，就可以用VS…\",\"fields\":{\"slug\":\"/VS Code的几个使用tip/\"},\"frontmatter\":{\"date\":\"02 December, 2017\",\"title\":\"VS Code的几个使用tip\"}}},{\"node\":{\"excerpt\":\"推荐视频： Philip Roberts  JSConf EU 2014 Erin Zimmer JSConf EU 2018 Jake Archibald JSConf.Asia 2018 Javascription的运行时环境其实最核心的两个部分就是Call Stack…\",\"fields\":{\"slug\":\"/事件循环原理/\"},\"frontmatter\":{\"date\":\"26 November, 2017\",\"title\":\"事件循环原理\"}}},{\"node\":{\"excerpt\":\"Promise 是异步编程的一种解决方案，比传统的解决方案 - 函数回调和事件，更合理和更强大，最早是由社区提出和实现的，后来ES…\",\"fields\":{\"slug\":\"/Promise及其垫片实现/\"},\"frontmatter\":{\"date\":\"06 September, 2017\",\"title\":\"Promise及其垫片实现\"}}},{\"node\":{\"excerpt\":\"设计模式有很多种，最早四人帮的书提出设计模式的时候总结了23种设计，加上后来其他开发者对这个基础上的变形和创新，一些讲JS设计模式的书里会有4、5…\",\"fields\":{\"slug\":\"/Javascript中的行为类设计模式/\"},\"frontmatter\":{\"date\":\"10 August, 2017\",\"title\":\"Javascript中的行为类设计模式\"}}},{\"node\":{\"excerpt\":\"…\",\"fields\":{\"slug\":\"/数据库分类笔记/\"},\"frontmatter\":{\"date\":\"20 July, 2017\",\"title\":\"数据库分类笔记\"}}},{\"node\":{\"excerpt\":\"与性能相关的事情不应该拖到项目的最后来做，要在项目的设计之初就开始考虑，这样才可以使性能的各种隐形需求完美地整合到项目中，随着项目一起推进 前端是庞大的，包括 HTML、CSS、 Javascript、Image 和 Font…\",\"fields\":{\"slug\":\"/网站性能优化总结/\"},\"frontmatter\":{\"date\":\"16 July, 2017\",\"title\":\"网站性能优化总结\"}}},{\"node\":{\"excerpt\":\"脚手架工具： 组件案例： prop和state的使用方法和React一致，所有的样式都通过style注入，只把应用作为一个整体注册一次，而不是每个组件/模块都注册 另外，React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点 常用的View…\",\"fields\":{\"slug\":\"/React-Native入门笔记/\"},\"frontmatter\":{\"date\":\"26 June, 2017\",\"title\":\"React-Native入门\"}}},{\"node\":{\"excerpt\":\"Proxy是一种特殊对象，可以用于代理其他对象的操作，或者说拦截了对其他对象的操作，从而可以实现对对象的监听，添加自定义逻辑，或者进行日志记录或者性能测试等操作 Proxy可以代理以下事件： apply，当调用函数的时候激活 construct，当通过 new…\",\"fields\":{\"slug\":\"/使用Proxy监听对象/\"},\"frontmatter\":{\"date\":\"25 May, 2017\",\"title\":\"使用Proxy监听对象\"}}},{\"node\":{\"excerpt\":\"在C之类的语言中，开发者必须手动地调用和释放内存，也就是手动地调用malloc()、calloc()、realloc() 和 free() 等方法，而在 Java或者Javascript…\",\"fields\":{\"slug\":\"/内存管理与垃圾回收/\"},\"frontmatter\":{\"date\":\"29 April, 2017\",\"title\":\"内存管理与垃圾回收\"}}},{\"node\":{\"excerpt\":\"原型链 原型是JS中的一个基本概念，所有的对象包括Object、Function、Array和Map等都有原型，原型能过prototype的引用指用其他对象，从而形成了原型链，对象的属性和方法可以通过原型链委托给其他对象，从而使得JS具有了模拟继承的能力 可以能过直接赋值Obj…\",\"fields\":{\"slug\":\"/Javascript忍者禁术笔记-Object/\"},\"frontmatter\":{\"date\":\"15 April, 2017\",\"title\":\"Javascript忍者禁术笔记-Object\"}}},{\"node\":{\"excerpt\":\"函数的特性 函数可以看作一种特殊的对象，可以赋值给变量，也可以作为同步或者异步的回调，同时也可以具有属性，可以记录执行的结果 创建函数的方法有很多，function声明、箭头函数、Function构造器、generator函数，函数可以作为其他函数的返回 创建函数 IIFE…\",\"fields\":{\"slug\":\"/Javascript忍者禁术笔记-Function/\"},\"frontmatter\":{\"date\":\"13 April, 2017\",\"title\":\"Javascript忍者禁术笔记-Function\"}}},{\"node\":{\"excerpt\":\"运行机制 javascript是解释型语言，采用JIT(Just In Time)机制，运行用机器码并不是提前生成的(AOT, Ahead Of Time)，这是与C等编译型语言的主要不同之一，javascript…\",\"fields\":{\"slug\":\"/Javascript忍者禁术笔记-Runtime/\"},\"frontmatter\":{\"date\":\"10 April, 2017\",\"title\":\"Javascript忍者禁术笔记-Runtime\"}}},{\"node\":{\"excerpt\":\"CommonJS模式 CommonJS是Node的主要模块机制，从设计的出发点就是考虑了服务端开发，关键字只有require和module.exports，exports是一个特殊属性，所有对它的赋值都会被export…\",\"fields\":{\"slug\":\"/JS的模块系统/\"},\"frontmatter\":{\"date\":\"19 January, 2017\",\"title\":\"JS的模块系统\"}}},{\"node\":{\"excerpt\":\"用scope避免命名冲突 创建可复用的npm init devDependencies的用外 npm脚本 版本管理 发布管理 安全检查\",\"fields\":{\"slug\":\"/Npm冷知识/\"},\"frontmatter\":{\"date\":\"13 January, 2017\",\"title\":\"Npm冷知识\"}}},{\"node\":{\"excerpt\":\"什么是Shadow DOM Shadow DOM 允许开发者在文档渲染时插入一棵DOM元素子树，但是这棵子树不在主DOM树中，因此开发者可利用Shadow DOM 封装自己的 HTML 标签、CSS 样式和 JavaScript 代码 很多我们常见的标签，比如video…\",\"fields\":{\"slug\":\"/什么是Shadow DOM/\"},\"frontmatter\":{\"date\":\"28 December, 2016\",\"title\":\"什么是Shadow DOM\"}}},{\"node\":{\"excerpt\":\"变量未定义会报错 删除一个变量/函数/函数参数的时候会报错 重复定义对象属性/函数参数会报错 使用八进制字面量和转义符会报错 删除只读属性会报错，非strict模式下会静默失败 赋值只有getter的属性会报错，非strict…\",\"fields\":{\"slug\":\"/JS里的严格模式/\"},\"frontmatter\":{\"date\":\"19 November, 2016\",\"title\":\"JS里的严格模式\"}}}]}},\"pathContext\":{\"category\":\"编程\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---categories-编程-adec43c86c7089b42d51.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Elvin's Blog\"}},\"allMarkdownRemark\":{\"edges\":[{\"node\":{\"excerpt\":\"…\",\"fields\":{\"slug\":\"/IntersectionObserver和懒加载优化/\"},\"frontmatter\":{\"date\":\"20 February, 2019\",\"title\":\"IntersectionObserver和懒加载优化\"}}},{\"node\":{\"excerpt\":\"PM2，Production Process Manager，是一个很好用的进程管理器，有很多优秀的特性，比如平滑的服务重启、直观的进程管理和日志监控、零配置负载均衡和友好的多服务器部署 以下是PM2的一些常用命令 模块扩展 \\npm2支持第三方扩展，比如常用的log rotate…\",\"fields\":{\"slug\":\"/PM2常用命令/\"},\"frontmatter\":{\"date\":\"26 December, 2018\",\"title\":\"PM2常用命令\"}}},{\"node\":{\"excerpt\":\"1xx的状态码表示临时响应 100 “continue” 用于让客户端得知服务端没有拒绝请求，可以发送正式的请求体，请求Header一般包含Expect 101 “switching protocols” 服务端按客户端请求变更协议，请求Header一般包含Upgrade 10…\",\"fields\":{\"slug\":\"/常见状态码和使用场景/\"},\"frontmatter\":{\"date\":\"22 December, 2018\",\"title\":\"常见架构模式笔记\"}}},{\"node\":{\"excerpt\":\"无事总结了下自己习惯用的Vue项目文件结构 清晰的项目结构有助于项目增长过程中的代码规范和质量管理，合理的项目结构能帮助新人更快地把握项目代码，自己开发时思路也会更加清晰，复用性的代码要支持按模块引入，减少多余的打包体积\",\"fields\":{\"slug\":\"/Vue项目结构总结/\"},\"frontmatter\":{\"date\":\"03 December, 2018\",\"title\":\"Vue项目结构总结\"}}},{\"node\":{\"excerpt\":\"Koa是Express的维护者们基于更简洁稳定和更充分利用Async/Await异步模式的目标重写的web框架，不自带任何中间件，Koa本身可以看作对http库的一层封装，一个Koa应用的开发可以理解为一系列中间件的组合 级联中间件 当中间件用异步方式调用next…\",\"fields\":{\"slug\":\"/Koa入门笔记/\"},\"frontmatter\":{\"date\":\"29 November, 2018\",\"title\":\"Koa入门笔记\"}}},{\"node\":{\"excerpt\":\"之前看VueConf，有一个Lightning Talk的内容挺有趣的，基本思路大概就是，Vue组件不一定要用来渲染HTML，或者说用组件这种声明式的写法可以做一些别的事情 下面提到的在Github上可以找到对应的项目： vue-motion 、 vue-promised…\",\"fields\":{\"slug\":\"/用Vue写不是组件的组件/\"},\"frontmatter\":{\"date\":\"22 November, 2018\",\"title\":\"\"}}},{\"node\":{\"excerpt\":\"Rollup 是一个和 Webpack 类似的 JavaScript 模块打包工具，不同的是 Rollup 默认对模块使用新的标准化格式，这些标准都是包含在 JavaScript 的 ES6 版本中的，而非以前的特殊解决方案，比如 CommonJS 和 AMD，ES…\",\"fields\":{\"slug\":\"/Rollup的基本使用/\"},\"frontmatter\":{\"date\":\"26 October, 2018\",\"title\":\"Rollup的基本使用\"}}},{\"node\":{\"excerpt\":\"SFC，Single File Component，Vue所谓的单文件组件，有时你可能需要快捷地把组件发布到npm给其他人使用，国外有开发者在VueConf分享了一套简便的模板，后来发现Vue Cookbook也已经采纳为一种推荐做法了 项目的地址是： vue-sfc…\",\"fields\":{\"slug\":\"/快捷发布Vue的单文件组件/\"},\"frontmatter\":{\"date\":\"02 October, 2018\",\"title\":\"快捷发布Vue的单文件组件\"}}},{\"node\":{\"excerpt\":\"CDN(Content Delivery Network, 内容分发网络) 是用于改善网络性能的一种解决方案 CDN…\",\"fields\":{\"slug\":\"/CDN基础总结/\"},\"frontmatter\":{\"date\":\"26 September, 2018\",\"title\":\"CDN基础总结\"}}},{\"node\":{\"excerpt\":\"Canvas性能优化的总体思路——在每一帧中，尽可能减少调用渲染相关 API 的次数，通常要以计算的复杂化为代价，尽可能调用渲染开销较低的 API，或者尽可能以渲染开销较低的方式调用渲染相关 API context的赋值开销 Canvas…\",\"fields\":{\"slug\":\"/Canvas性能优化总结/\"},\"frontmatter\":{\"date\":\"20 September, 2018\",\"title\":\"Canvas性能优化总结\"}}},{\"node\":{\"excerpt\":\"维基百科定义中，架构模式是指：在给定环境中，对常见的软件架构问题的一种通用的、可复用的解决方案，架构模式与设计模式很相似，只是边界范围更明确 Layered Pattern 层级模式 Client-Sever Pattern 客户端-服务端模式 Master-Slave…\",\"fields\":{\"slug\":\"/常见架构模式笔记/\"},\"frontmatter\":{\"date\":\"22 August, 2018\",\"title\":\"常见架构模式笔记\"}}},{\"node\":{\"excerpt\":\"在之前的博客里我提到过用Canvas实现天气效果，后面我偶然用Chrome的Performance Monitor查看这个页面的内存情况，发现切换几次天气后，CPU占用率从20%升到了90%，断定有性能效果，初步猜测是有内部自动GC…\",\"fields\":{\"slug\":\"/性能问题排查: bind(this)/\"},\"frontmatter\":{\"date\":\"21 August, 2018\",\"title\":\"性能问题排查: bind(this)\"}}},{\"node\":{\"excerpt\":\"最近在 Paul Levis 的 Youtube 频道更新了他关于如何实现下雪效果的视频，心血来潮就将他的做法拓展了一下，简单实现了下 Rainy、Snowy、Starry 和 Cloudy 四种天气 Demo 的传送门在这里： Weather Canvas…\",\"fields\":{\"slug\":\"/用Canvas实现简单的天气效果/\"},\"frontmatter\":{\"date\":\"11 August, 2018\",\"title\":\"用Canvas实现简单的天气效果\"}}},{\"node\":{\"excerpt\":\"代码分片指的是在构建打包的过程中，把代码分成片段打包为块文件的过程，并在页面需要时加载 现在Webpack推荐的文件打包后的大小标准是：js < 200kb，css < 100kb，coverage > 90% Coverage…\",\"fields\":{\"slug\":\"/代码分片的常见场景/\"},\"frontmatter\":{\"date\":\"06 August, 2018\",\"title\":\"代码分片的常见场景\"}}},{\"node\":{\"excerpt\":\"RAIL is a User-centric performance model that breaks down the user’s experience into key actions. Every web app has four distinct aspects to…\",\"fields\":{\"slug\":\"/RAIL性能模型笔记/\"},\"frontmatter\":{\"date\":\"26 July, 2018\",\"title\":\"RAIL性能模型笔记\"}}},{\"node\":{\"excerpt\":\"Redux 创建Store 使用Store React Redux 通过Provider注入store 状态映射 简化版本如下 合并Reducers Redux Middleware 创建中间件 应用中间件 其他 Redux Documentation\",\"fields\":{\"slug\":\"/Redux基础/\"},\"frontmatter\":{\"date\":\"26 July, 2018\",\"title\":\"Redux基础\"}}},{\"node\":{\"excerpt\":\"Everything is an element. Concepts Polymer lets you build encapsulated, reusable  Web Components  that work just like standard HTML elements…\",\"fields\":{\"slug\":\"/Ploymer入门/\"},\"frontmatter\":{\"date\":\"26 July, 2018\",\"title\":\"Ploymer入门\"}}},{\"node\":{\"excerpt\":\"Javascript是一门天生有异步基因的语言，这是由于事件循环和浏览器的交互机制等原因决定的 对于异步流程的控制，我们经历了从最早的 callback，然后是 Promise，到现在的Async/Await和Generator，方式变得越来越灵活 Async/Await…\",\"fields\":{\"slug\":\"/异步流程控制与错误处理/\"},\"frontmatter\":{\"date\":\"12 July, 2018\",\"title\":\"异步流程控制与错误处理\"}}},{\"node\":{\"excerpt\":\"假设有一个业务场景是这样的，根据一个微博或者其他社交媒体的图片搜索接口，不停地切换展示图片，比如说不断切换微博有关于猫的图片，每张图片只展示一次，常见的思路就是分页+轮询 对于这种生成不间断的数据流的模式，其实也可以用迭代器和generator的思路来做： switchCat…\",\"fields\":{\"slug\":\"/Generator与asyncIterator/\"},\"frontmatter\":{\"date\":\"26 June, 2018\",\"title\":\"Generator与asyncIterator\"}}},{\"node\":{\"excerpt\":\"Worker  是在 Javascript 中实现多线程的一种方法，通常用于进行耗时/次要的任务，可以提高计算速度，并且达到不阻塞UI的目的 在 Web Workers API 中，Worker可以分为  dedicated Woker ， SharedWorker…\",\"fields\":{\"slug\":\"/Web Worker笔记/\"},\"frontmatter\":{\"date\":\"26 June, 2018\",\"title\":\"Web Workers笔记\"}}},{\"node\":{\"excerpt\":\"很多性能优化比较关注于Page Load Time (PLT)，比如经典的雅虎14条中提到的合并请求和压缩静态资源等等，但除去网站加载的时间以外，用户大部分的时间是花在与页面的交互上 因此页面渲染的性能也是关键优化点，包括UI反馈和动画等，最终目标都是提供给用户60fps…\",\"fields\":{\"slug\":\"/页面渲染问题总结/\"},\"frontmatter\":{\"date\":\"25 May, 2018\",\"title\":\"页面渲染问题总结\"}}},{\"node\":{\"excerpt\":\"Babel 是 Javascript 的转译工具，可以帮助开发者在写代码的时候可以使用更先进的语法和API，并在运行前转译为更具兼容性的语法 确立  ECMAScript  标准语法的五阶段: Stage 0：strawman - “稻草人” Stage 1：proposal…\",\"fields\":{\"slug\":\"/Babel笔记/\"},\"frontmatter\":{\"date\":\"20 May, 2018\",\"title\":\"Babel笔记\"}}},{\"node\":{\"excerpt\":\"…\",\"fields\":{\"slug\":\"/前端工程师的一专多长/\"},\"frontmatter\":{\"date\":\"17 May, 2018\",\"title\":\"前端工程师的一专多长\"}}},{\"node\":{\"excerpt\":\"后端监控  - 采集服务器以及链路上各种中间件的数据\\n 前端监控  - 运行在用户终端上的代码 最简实现：通过 window.onerror 采集到所有的未捕获异常，并通过 new Image() 的方式构造一个 404 的 HTTP 请求，最后在服务端实时过滤 access…\",\"fields\":{\"slug\":\"/前端监控系统总结/\"},\"frontmatter\":{\"date\":\"06 April, 2018\",\"title\":\"前端监控系统总结\"}}},{\"node\":{\"excerpt\":\"编程范式  是指一种基于基本原则来思考如何构建软件的方式，常见的范式还有  面向对象编程 、 面向过程编程  和  函数式编程 函数式编程 （Functional Programming…\",\"fields\":{\"slug\":\"/函数式编程基本概念/\"},\"frontmatter\":{\"date\":\"06 March, 2018\",\"title\":\"函数式编程基本概念\"}}},{\"node\":{\"excerpt\":\"P5.js P5.js源于Processing，它们原来的出发点都是使图形编程可供艺术家，设计师，教育工作者和初学者使用，而Processing是很多年前提出的技术了，其实现其实是使用regex将Java转换为JS，而P5.js则是以原生JavaScript…\",\"fields\":{\"slug\":\"/P5.js和贪吃蛇游戏/\"},\"frontmatter\":{\"date\":\"02 February, 2018\",\"title\":\"P5.js和贪吃蛇游戏\"}}},{\"node\":{\"excerpt\":\"首先需要购置一台VPN用主机和自用域名，将域名 DOMAIN 的 A/AAAA 记录指向该主机，安装nginx并启动，主机推荐腾讯云香港区域的S1系列（CentOS） Let’s Encrypt 为了内容传输的隐密性，可以采用 Let’s Encrypt…\",\"fields\":{\"slug\":\"/用OpenConnectSever搭建VPN/\"},\"frontmatter\":{\"date\":\"26 January, 2018\",\"title\":\"OpenConnectSever搭建VPN总结\"}}},{\"node\":{\"excerpt\":\"从最简单的方式开始 通常方法我们会提取到prototype中复用以节约内存 但是这样并没有达到真正私有变量的目的，只是单纯地用了命名惯例而已，于是可以算要用一个闭包才形有私有作用域 但这些多个Person类间的name…\",\"fields\":{\"slug\":\"/如何实现javascript的私有变量/\"},\"frontmatter\":{\"date\":\"26 January, 2018\",\"title\":\"如何实现javascript的私有变量\"}}},{\"node\":{\"excerpt\":\"大前端，简而言之，就是统一三端的开发( Web, Desktop, Mobile) 现在前端涉及的领域十分广泛，各种技术层出不穷—— 在多媒体领域，比如基于 WebRTC 的语音视频通话，基于P2P + CDN的流建媒体分发网络技术 在图形学领域，比如AR / VR…\",\"fields\":{\"slug\":\"/关于大前端/\"},\"frontmatter\":{\"date\":\"26 December, 2017\",\"title\":\"关于大前端\"}}},{\"node\":{\"excerpt\":\"箭头函数用起来比较潮，但是原来的函数写法依旧有其用处，毕竟这两者还有很多不等价的情况 箭头函数缺失的东西 没有自己的 this ，其this是由执行时在当前scope中继承的 没有 prototype 属性，所以用于new，如 没有 arguments 对象，也没有 new…\",\"fields\":{\"slug\":\"/箭头函数总结/\"},\"frontmatter\":{\"date\":\"26 December, 2017\",\"title\":\"箭头函数总结\"}}},{\"node\":{\"excerpt\":\"从命令行打开当前目录 按 Shift + Command + P，调出Command Panel 输入并选择 Install ‘code’ command in PATH，如果没有这条命令的话，则有可能是已经添加过了，然后再打开terminal里执行code，就可以用VS…\",\"fields\":{\"slug\":\"/VS Code的几个使用tip/\"},\"frontmatter\":{\"date\":\"02 December, 2017\",\"title\":\"VS Code的几个使用tip\"}}},{\"node\":{\"excerpt\":\"推荐视频： Philip Roberts  JSConf EU 2014 Erin Zimmer JSConf EU 2018 Jake Archibald JSConf.Asia 2018 Javascription的运行时环境其实最核心的两个部分就是Call Stack…\",\"fields\":{\"slug\":\"/事件循环原理/\"},\"frontmatter\":{\"date\":\"26 November, 2017\",\"title\":\"事件循环原理\"}}},{\"node\":{\"excerpt\":\"Promise 是异步编程的一种解决方案，比传统的解决方案 - 函数回调和事件，更合理和更强大，最早是由社区提出和实现的，后来ES…\",\"fields\":{\"slug\":\"/Promise及其垫片实现/\"},\"frontmatter\":{\"date\":\"06 September, 2017\",\"title\":\"Promise及其垫片实现\"}}},{\"node\":{\"excerpt\":\"设计模式有很多种，最早四人帮的书提出设计模式的时候总结了23种设计，加上后来其他开发者对这个基础上的变形和创新，一些讲JS设计模式的书里会有4、5…\",\"fields\":{\"slug\":\"/Javascript中的行为类设计模式/\"},\"frontmatter\":{\"date\":\"10 August, 2017\",\"title\":\"Javascript中的行为类设计模式\"}}},{\"node\":{\"excerpt\":\"…\",\"fields\":{\"slug\":\"/数据库分类笔记/\"},\"frontmatter\":{\"date\":\"20 July, 2017\",\"title\":\"数据库分类笔记\"}}},{\"node\":{\"excerpt\":\"与性能相关的事情不应该拖到项目的最后来做，要在项目的设计之初就开始考虑，这样才可以使性能的各种隐形需求完美地整合到项目中，随着项目一起推进 前端是庞大的，包括 HTML、CSS、 Javascript、Image 和 Font…\",\"fields\":{\"slug\":\"/网站性能优化总结/\"},\"frontmatter\":{\"date\":\"16 July, 2017\",\"title\":\"网站性能优化总结\"}}},{\"node\":{\"excerpt\":\"脚手架工具： 组件案例： prop和state的使用方法和React一致，所有的样式都通过style注入，只把应用作为一个整体注册一次，而不是每个组件/模块都注册 另外，React Native中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点 常用的View…\",\"fields\":{\"slug\":\"/React-Native入门笔记/\"},\"frontmatter\":{\"date\":\"26 June, 2017\",\"title\":\"React-Native入门\"}}},{\"node\":{\"excerpt\":\"Proxy是一种特殊对象，可以用于代理其他对象的操作，或者说拦截了对其他对象的操作，从而可以实现对对象的监听，添加自定义逻辑，或者进行日志记录或者性能测试等操作 Proxy可以代理以下事件： apply，当调用函数的时候激活 construct，当通过 new…\",\"fields\":{\"slug\":\"/使用Proxy监听对象/\"},\"frontmatter\":{\"date\":\"25 May, 2017\",\"title\":\"使用Proxy监听对象\"}}},{\"node\":{\"excerpt\":\"在C之类的语言中，开发者必须手动地调用和释放内存，也就是手动地调用malloc()、calloc()、realloc() 和 free() 等方法，而在 Java或者Javascript…\",\"fields\":{\"slug\":\"/内存管理与垃圾回收/\"},\"frontmatter\":{\"date\":\"29 April, 2017\",\"title\":\"内存管理与垃圾回收\"}}},{\"node\":{\"excerpt\":\"原型链 原型是JS中的一个基本概念，所有的对象包括Object、Function、Array和Map等都有原型，原型能过prototype的引用指用其他对象，从而形成了原型链，对象的属性和方法可以通过原型链委托给其他对象，从而使得JS具有了模拟继承的能力 可以能过直接赋值Obj…\",\"fields\":{\"slug\":\"/Javascript忍者禁术笔记-Object/\"},\"frontmatter\":{\"date\":\"15 April, 2017\",\"title\":\"Javascript忍者禁术笔记-Object\"}}},{\"node\":{\"excerpt\":\"函数的特性 函数可以看作一种特殊的对象，可以赋值给变量，也可以作为同步或者异步的回调，同时也可以具有属性，可以记录执行的结果 创建函数的方法有很多，function声明、箭头函数、Function构造器、generator函数，函数可以作为其他函数的返回 创建函数 IIFE…\",\"fields\":{\"slug\":\"/Javascript忍者禁术笔记-Function/\"},\"frontmatter\":{\"date\":\"13 April, 2017\",\"title\":\"Javascript忍者禁术笔记-Function\"}}},{\"node\":{\"excerpt\":\"运行机制 javascript是解释型语言，采用JIT(Just In Time)机制，运行用机器码并不是提前生成的(AOT, Ahead Of Time)，这是与C等编译型语言的主要不同之一，javascript…\",\"fields\":{\"slug\":\"/Javascript忍者禁术笔记-Runtime/\"},\"frontmatter\":{\"date\":\"10 April, 2017\",\"title\":\"Javascript忍者禁术笔记-Runtime\"}}},{\"node\":{\"excerpt\":\"CommonJS模式 CommonJS是Node的主要模块机制，从设计的出发点就是考虑了服务端开发，关键字只有require和module.exports，exports是一个特殊属性，所有对它的赋值都会被export…\",\"fields\":{\"slug\":\"/JS的模块系统/\"},\"frontmatter\":{\"date\":\"19 January, 2017\",\"title\":\"JS的模块系统\"}}},{\"node\":{\"excerpt\":\"用scope避免命名冲突 创建可复用的npm init devDependencies的用外 npm脚本 版本管理 发布管理 安全检查\",\"fields\":{\"slug\":\"/Npm冷知识/\"},\"frontmatter\":{\"date\":\"13 January, 2017\",\"title\":\"Npm冷知识\"}}},{\"node\":{\"excerpt\":\"什么是Shadow DOM Shadow DOM 允许开发者在文档渲染时插入一棵DOM元素子树，但是这棵子树不在主DOM树中，因此开发者可利用Shadow DOM 封装自己的 HTML 标签、CSS 样式和 JavaScript 代码 很多我们常见的标签，比如video…\",\"fields\":{\"slug\":\"/什么是Shadow DOM/\"},\"frontmatter\":{\"date\":\"28 December, 2016\",\"title\":\"什么是Shadow DOM\"}}},{\"node\":{\"excerpt\":\"变量未定义会报错 删除一个变量/函数/函数参数的时候会报错 重复定义对象属性/函数参数会报错 使用八进制字面量和转义符会报错 删除只读属性会报错，非strict模式下会静默失败 赋值只有getter的属性会报错，非strict…\",\"fields\":{\"slug\":\"/JS里的严格模式/\"},\"frontmatter\":{\"date\":\"19 November, 2016\",\"title\":\"JS里的严格模式\"}}}]}},\"pathContext\":{\"category\":\"编程\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/categories-编程.json\n// module id = 448\n// module chunks = 260249089781156"],"sourceRoot":""}